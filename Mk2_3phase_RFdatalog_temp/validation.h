/**
 * @file validation.h
 * @author Frédéric Metrich (frederic.metrich@live.fr)
 * @brief Compile-time validations
 * @version 0.1
 * @date 2023-02-09
 * 
 * @copyright Copyright (c) 2023
 * 
 */

#ifndef VALIDATION_H
#define VALIDATION_H

#include "config_system.h"
#include "utils_pins.h"
#include "utils_rf.h"

#include "config.h"

/**
 * @note All these checks are done by the compiler.
 * It does not take ANY space in the Arduino.
 * 
 * DO NOT EDIT THIS FILE
 * 
 */

static_assert(DATALOG_PERIOD_IN_SECONDS <= 40, "**** Data log duration is too long and will lead to overflow ! ****");

static_assert(TEMP_SENSOR_PRESENT ^ (temperatureSensing.get_pin() == 0xff), "******** Wrong pin value for temperature sensor(s). Please check your config.h ! ********");
static_assert(DIVERSION_PIN_PRESENT ^ (diversionPin == 0xff), "******** Wrong pin value for diversion command. Please check your config.h ! ********");
static_assert((PRIORITY_ROTATION == RotationModes::PIN) ^ (rotationPin == 0xff), "******** Wrong pin value for rotation command. Please check your config.h ! ********");
static_assert(OVERRIDE_PIN_PRESENT ^ (forcePin == 0xff), "******** Wrong pin value for override command. Please check your config.h ! ********");
static_assert(WATCHDOG_PIN_PRESENT ^ (watchDogPin == 0xff), "******** Wrong pin value for watchdog. Please check your config.h ! ********");

static_assert(DUAL_TARIFF ^ (dualTariffPin == 0xff), "******** Wrong pin value for dual tariff. Please check your config.h ! ********");
static_assert(!DUAL_TARIFF | (ul_OFF_PEAK_DURATION == 0), "******** Off-peak duration cannot be zero. Please check your config.h ! ********");
static_assert(!(DUAL_TARIFF & (ul_OFF_PEAK_DURATION > 12)), "******** Off-peak duration cannot last more than 12 hours. Please check your config.h ! ********");

static_assert(!EMONESP_CONTROL || (DIVERSION_PIN_PRESENT && DIVERSION_PIN_PRESENT && (PRIORITY_ROTATION == RotationModes::PIN) && OVERRIDE_PIN_PRESENT), "******** Wrong configuration. Please check your config.h ! ********");

static_assert(!RELAY_DIVERSION | (60 / DATALOG_PERIOD_IN_SECONDS * DATALOG_PERIOD_IN_SECONDS == 60), "******** Wrong configuration. DATALOG_PERIOD_IN_SECONDS must be a divider of 60 ! ********");

static_assert(NO_OF_DUMPLOADS > 0, "Number of dump loads must be greater than 0");
static_assert(iTemperatureThreshold > 0, "Temperature threshold must be greater than 0");
static_assert(iTemperatureThreshold <= 100, "Temperature threshold must be lower than 100");

constexpr uint16_t check_pins()
{
  uint16_t used_pins{ 0 };

  if constexpr (TEMP_SENSOR_PRESENT)
  {
    if (temperatureSensing.get_pin() != 0xff)
      bit_set(used_pins, temperatureSensing.get_pin());
  }

  if (diversionPin != 0xff)
  {
    if (bit_read(used_pins, diversionPin))
      return 0;

    bit_set(used_pins, diversionPin);
  }

  if (rotationPin != 0xff)
  {
    if (bit_read(used_pins, rotationPin))
      return 0;

    bit_set(used_pins, rotationPin);
  }

  if (forcePin != 0xff)
  {
    if (bit_read(used_pins, forcePin))
      return 0;

    bit_set(used_pins, forcePin);
  }

  if (watchDogPin != 0xff)
  {
    if (bit_read(used_pins, watchDogPin))
      return 0;

    bit_set(used_pins, watchDogPin);
  }

  //physicalLoadPin for the TRIACS
  for (const auto &loadPin : physicalLoadPin)
  {
    if (loadPin == 0xff)
      return 0;

    if (bit_read(used_pins, loadPin))
      return 0;

    bit_set(used_pins, loadPin);
  }

  if constexpr (RELAY_DIVERSION)
  {
    for (uint8_t idx = 0; idx < relays.get_size(); ++idx)
    {
      const auto relayPin = relays.get_relay(idx).get_pin();

      if (relayPin != 0xff)
      {
        if (bit_read(used_pins, relayPin))
          return 0;

        bit_set(used_pins, relayPin);
      }
    }
  }

  return used_pins;
}

constexpr uint16_t check_relay_pins()
{
  bool pins_ok{ true };

  for (uint8_t idx = 0; idx < relays.get_size(); ++idx)
  {
    const auto relayPin = relays.get_relay(idx).get_pin();

    if constexpr (RELAY_DIVERSION)
    {
      pins_ok &= (relayPin != 0xff);
    }
    else
    {
      pins_ok &= (relayPin == 0xff);
    }
  }

  return pins_ok;
}

constexpr bool check_load_priorities()
{
  uint8_t _sum{ 0 };
  uint16_t _enum_val{ 0 };

  for (const auto &loadPrio : loadPrioritiesAtStartup)
  {
    // we check if a prio is used twice
    if (bit_read(_enum_val, loadPrio))
      return 0;

    bit_set(_enum_val, loadPrio);

    _sum += loadPrio;
  }

  // check if we have all prio between 0 and (NO_OF_DUMPLOADS - 1)
  return _sum == ((NO_OF_DUMPLOADS * (NO_OF_DUMPLOADS - 1)) >> 1);
}

static_assert(check_load_priorities(), "******** Load Priorities wrong ! Please check your config ! ********");
static_assert(check_pins(), "******** Duplicate pin definition ! Please check your config ! ********");
static_assert((check_pins() & B00000011) == 0, "******** Pins 0 & 1 are reserved for RX/TX ! Please check your config ! ********");
static_assert((check_pins() & 0xC000) == 0, "******** Pins 14 and/or 15 do not exist ! Please check your config ! ********");
static_assert(!(RF_CHIP_PRESENT && ((check_pins() & 0x3C04) != 0)), "******** Pins from RF chip are reserved ! Please check your config ! ********");
static_assert(check_relay_pins(), "******** Wrong pin(s) configuration for relay(s) ********");

#endif /* VALIDATION_H */
