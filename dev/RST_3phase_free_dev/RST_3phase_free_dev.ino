/* February 2014
 * Tool to capture the raw V and I samples generated by the Atmega 328P processor
 * during one or more mains cycles.  The data is displayed on the Serial Monitor.
 *
 * Voltage samples are displayed as 'v'
 * Current samples via CT1 are displayed as '1'
 *
 * The display is more compact if not every set of samples is shown.  This aspect
 * can be changed at the second of the two lines of code which contain a '%' character.
 *
 * February 2021
 * In the original version, data samples were obtained using the analogRead() function.  Now,
 * they are obtained by the ADC being controlled by a hardware timer with a periodicity of 125 us,
 * hence a full set of 1 x V and 2 x I samples takes 375 us.  The same scheme for collecting
 * data samples is found in many of my Mk2 PV Router sketches.
 *
 * When used with an output stage that has zero-crossing detection, the signal at port D4 can
 * be used to activate a load for just a single half main cycle.  The behaviour of the output signal
 * from CT1 can then be studied in detail.
 *
 * The stream of raw data samples from any floating CT will always be distorted because the CT acts as
 * a High Pass Filter.  This effect is only noticeable when the current that is being measured changes,
 * such as when an electrical load is turned on or off.  This sketch includes additional software which
 * compensates for this effect.  Similar compensation software has been introduced to the various
 * "fasterControl" sketches that now exist.
 *
 *      Robin Emley
 *      www.Mk2PVrouter.co.uk
 *      June 2021
 */

#include <Arduino.h>
#include "utils_pins.h"

// definition of enumerated types
enum polarities
{
  NEGATIVE,
  POSITIVE
};

constexpr uint8_t ADC_TIMER_PERIOD{ 104 };  // uS (determines the sampling rate / amount of idle time)
constexpr uint8_t MAINS_CYCLES_PER_SECOND{ 50 };

constexpr uint8_t NO_OF_PHASES{ 3 }; /**< number of phases of the main supply. */

constexpr uint8_t outputForTrigger{ 5 };  // active high

// analogue input pins
byte sensorV[NO_OF_PHASES]{ 0, 2, 4 };
byte sensorI[NO_OF_PHASES]{ 1, 3, 5 };

uint32_t cycleCount{ 0 };
uint16_t samplesRecorded{ 0 };
constexpr int16_t DCoffsetI_nominal{ 511 };  // nominal mid-point value of ADC @ x1 scale

int32_t DCoffset_V_long;  // <--- for LPF
int32_t DCoffset_V_min;   // <--- for LPF
int32_t DCoffset_V_max;   // <--- for LPF

// extra items for an LPF to improve the processing of data samples from CT1
int32_t lpf_long = 512;  // new LPF, for offsetting the behaviour of CT1 as a HPF
//
// The next two constants determine the profile of the LPF.
// They are matched to the physical behaviour of the YHDC SCT-013-000 CT
// and the CT1 samples being 3x104us apart (free-running mode)
//
constexpr float lpf_gain{ 12 };  // <- setting this to 0 disables this extra processing
// const float lpf_gain = 0;  // <- setting this to 0 disables this extra processing
constexpr float alpha{ 0.002 };  //

// for interaction between the main processor and the ISRs
volatile bool newCycle{ false };
volatile bool dataReady{ false };
volatile int16_t sample_I1;
volatile int16_t sample_V1;

enum polarities polarityOfMostRecentVsample;
enum polarities polarityOfLastVsample;
bool beyondStartUpPhase = false;

int lastSample_V;             // stored value from the previous loop (HP filter is for voltage samples only)
float lastFiltered_V;         //  voltage values after HP-filtering to remove the DC offset
byte polarityOfLastSample_V;  // for zero-crossing detection

volatile bool recordingNow{ false };
volatile bool recordingComplete{ false };
volatile byte cycleNumberBeingRecorded{ 0 };
constexpr byte noOfCyclesToBeRecorded{ 3 };  // more array space may be needed if this value is >1 !!!
constexpr byte noOfADCConversion{ 6 };

unsigned long recordingMayStartAt{ 0 };
bool firstLoop{ true };
constexpr uint16_t settlingDelay{ 5 };  // <<---  settling time (seconds) for HPF

char blankLine[82];
char newLine[82];

constexpr uint16_t noOfSamples{ 1000000 / MAINS_CYCLES_PER_SECOND * noOfCyclesToBeRecorded / (ADC_TIMER_PERIOD * noOfADCConversion) };

int storedSample_V1[noOfSamples + 10];
int storedSample_I1[noOfSamples + 10];
int storedSample_I1_from_ADC[noOfSamples + 10];

/**
 * @brief Called once during startup.
 * @details This function initializes a couple of variables we cannot init at compile time and
 *          sets a couple of parameters for runtime.
 *
 */
void setup()
{
  pinMode(outputForTrigger, OUTPUT);
  setPinOFF(outputForTrigger);

  Serial.begin(9600);
  Serial.println();
  Serial.println("-------------------------------------");
  Serial.println("Sketch ID:      RST_3phase_free_dev.ino");
  //
  Serial.print("alpha = ");
  Serial.println(alpha, 4);
  Serial.print("lpf_gain = ");
  Serial.println(lpf_gain, 1);
  Serial.println();

  // initialise each character of the display line
  blankLine[0] = '|';
  blankLine[80] = '|';

  for (uint8_t i = 1; i < 80; ++i)
  {
    blankLine[i] = ' ';
  }
  blankLine[40] = '.';

  // Define operating limits for the LP filter which identifies DC offset in the voltage
  // sample stream.  By limiting the output range, the filter always should start up
  // correctly.
  DCoffset_V_long = 512L * 256;               // nominal mid-point value of ADC @ x256 scale
  DCoffset_V_min = (long)(512L - 100) * 256;  // mid-point of ADC minus a working margin
  DCoffset_V_max = (long)(512L + 100) * 256;  // mid-point of ADC plus a working margin

  // First stop the ADC
  bit_clear(ADCSRA, ADEN);

  // Activate free-running mode
  ADCSRB = 0x00;

  // Set up the ADC to be free-running
  bit_set(ADCSRA, ADPS0);  // Set the ADC's clock to system clock / 128
  bit_set(ADCSRA, ADPS1);
  bit_set(ADCSRA, ADPS2);

  bit_set(ADCSRA, ADATE);  // set the Auto Trigger Enable bit in the ADCSRA register. Because
  // bits ADTS0-2 have not been set (i.e. they are all zero), the
  // ADC's trigger source is set to "free running mode".

  bit_set(ADCSRA, ADIE);  // set the ADC interrupt enable bit. When this bit is written
  // to one and the I-bit in SREG is set, the
  // ADC Conversion Complete Interrupt is activated.

  bit_set(ADCSRA, ADEN);  // Enable the ADC

  startADC();

  sei();  // Enable Global Interrupts

  Serial.print(">>free RAM = ");
  Serial.println(freeRam());  // a useful value to keep an eye on
}

void startADC(void)
{
  bit_set(ADCSRA, ADSC);
}
void stopADC(void)
{
  bit_clear(ADCSRA, ADSC);
}

ISR(ADC_vect)
{
  static unsigned char sample_index = 0;
  static uint16_t raw_sample;
  static uint16_t sample_I1_raw;

  switch (sample_index)
  {
    case 0:
      sample_V1 = ADC;                  // store the ADC value (this one is for Voltage)
      ADMUX = bit(REFS0) + sensorV[1];  // the conversion for I1 is already under way
      // ADCSRA |= (1 << ADSC);    // start the ADC
      ++sample_index;  // increment the control flag
      sample_I1 = sample_I1_raw;

      dataReady = true;
      break;
    case 1:
      sample_I1_raw = ADC;              // store the ADC value (this one is for current at CT1)
      ADMUX = bit(REFS0) + sensorI[1];  // the conversion for V2 is already under way
      // ADCSRA |= (1 << ADSC);    // start the ADC
      ++sample_index;  // increment the control flag
      break;
    case 2:
      raw_sample = ADC;                 // store the ADC value (this one is for current at CT2)
      ADMUX = bit(REFS0) + sensorV[2];  // the conversion for I2 is already under way
      // ADCSRA |= (1 << ADSC);   // start the ADC
      ++sample_index;  // increment the control flag
      break;
    case 3:
      raw_sample = ADC;                 // store the ADC value (this one is for current at CT2)
      ADMUX = bit(REFS0) + sensorI[2];  // the conversion for V3 is already under way
      // ADCSRA |= (1 << ADSC);   // start the ADC
      ++sample_index;  // increment the control flag
      break;
    case 4:
      raw_sample = ADC;                 // store the ADC value (this one is for current at CT2)
      ADMUX = bit(REFS0) + sensorV[0];  // the conversion for I3 is already under way
      // ADCSRA |= (1 << ADSC);   // start the ADC
      ++sample_index;  // increment the control flag
      break;
    case 5:
      raw_sample = ADC;                 // store the ADC value (this one is for current at CT2)
      ADMUX = bit(REFS0) + sensorI[0];  // the conversion for V1 is already under way
      // ADCSRA |= (1 << ADSC);   // start the ADC
      sample_index = 0;  // reset the control flag
      break;
    default:
      sample_index = 0;  // to prevent lockup (should never get here)
  }
}

/**
 * @brief Main processor.
 * @details None of the workload in loop() is time-critical.
 *          All the processing of ADC data is done within the ISR.
 *
 */
void loop()
{
  static uint8_t perSecondTimer{ 0 };

  if (dataReady)  // flag is set after every new Cycle
  {
    dataReady = false;       // reset the flag
    allGeneralProcessing();  // executed once for each set of V&I samples
  }
}

/*  Allow the system to run for several seconds so that the filtered
 *  voltage waveform can settle down.  This info is needed for determining
 *  the start of each new mains cycle.  During this period, a countdown
 *  is displayed.
 *
 *  After the settling period has expired, raw samples taken during one or
 *  more complete mains cycles are stored in an array.  The capacity of the
 *  array needs to be sufficient for the number of sample pairs that may
 *  appear.
 *
 *  At the start of the following cycle, the data collected during the
 *  previous mains cycle(s) is sent to the Serial window.
 */
void allGeneralProcessing()  // each iteration is for one set of data samples
{
  static long cumVdeltasThisCycle_long{ 0 };  // for the LPF which determines DC offset (voltage)
  static int sampleSetsDuringThisHalfMainsCycle{ 0 };
  //
  if (firstLoop)
  {
    unsigned long timeNow = millis();
    Serial.print("millis() now = ");
    Serial.println(timeNow);

    recordingMayStartAt = timeNow + (settlingDelay * 1000);
    Serial.print("recordingMayStartAt ");
    Serial.println(recordingMayStartAt);

    recordingNow = false;
    firstLoop = false;
    recordingComplete = false;
    cycleNumberBeingRecorded = 0;
    samplesRecorded = 0;
  }

  // remove DC offset from the raw voltage sample by subtracting the accurate value
  // as determined by a LP filter.
  long sample_VminusDC_long = ((long)sample_V1 << 8) - DCoffset_V_long;

  // determine the polarity of the latest voltage sample
  if (sample_VminusDC_long > 0)
  {
    polarityOfMostRecentVsample = POSITIVE;
  }
  else
  {
    polarityOfMostRecentVsample = NEGATIVE;
  }

  if (polarityOfMostRecentVsample == POSITIVE)
  {
    if (polarityOfLastVsample != POSITIVE)
    {
      // This is the start of a new mains cycle
      //togglePin(2);

      ++cycleCount;
      sampleSetsDuringThisHalfMainsCycle = 0;

      if (recordingNow)
      {
        if (cycleNumberBeingRecorded >= noOfCyclesToBeRecorded)
        {
          Serial.print("No of cycles recorded = ");
          Serial.println(cycleNumberBeingRecorded);
          dispatch_recorded_raw_data();
          dispatch_recorded_data();
        }
        else
        {
          ++cycleNumberBeingRecorded;
        }
      }
      else if ((cycleCount % MAINS_CYCLES_PER_SECOND) == 1)
      {
        unsigned long timeNow = millis();
        if (timeNow > recordingMayStartAt)
        {
          recordingNow = true;
          ++cycleNumberBeingRecorded;
        }
        else
        {
          Serial.println((int)(recordingMayStartAt - timeNow) / 1000);
        }
      }
    }  // end of specific processing for first +ve Vsample in each mains cycle

    // still processing samples where the voltage is POSITIVE ...
    // check to see whether the trigger device can now be reliably armed
    if ((sampleSetsDuringThisHalfMainsCycle == 3) && (cycleNumberBeingRecorded == 1))
    {
      setPinON(outputForTrigger);  // triac will fire at the next ZC point
      storedSample_V1[samplesRecorded] = 999;
      storedSample_I1[samplesRecorded] = 999;
      storedSample_I1_from_ADC[samplesRecorded] = 999;
      ++samplesRecorded;
    }
    // check to see whether the trigger device can now be reliably disarmed
    if ((sampleSetsDuringThisHalfMainsCycle == 3) && (cycleNumberBeingRecorded == 2))
    {
      setPinOFF(outputForTrigger);  // triac will release at the next ZC point
      storedSample_V1[samplesRecorded] = 0;
      storedSample_I1[samplesRecorded] = 0;
      storedSample_I1_from_ADC[samplesRecorded] = 0;
      ++samplesRecorded;
    }
  }     // end of specific processing of +ve cycles
  else  // the polarity of this sample is negative
  {
    if (polarityOfLastVsample != NEGATIVE)
    {
      sampleSetsDuringThisHalfMainsCycle = 0;

      long previousOffset = DCoffset_V_long;
      DCoffset_V_long = previousOffset + (cumVdeltasThisCycle_long >> 12);
      cumVdeltasThisCycle_long = 0;

      if (DCoffset_V_long < DCoffset_V_min)
      {
        DCoffset_V_long = DCoffset_V_min;
      }
      else if (DCoffset_V_long > DCoffset_V_max)
      {
        DCoffset_V_long = DCoffset_V_max;
      }
    }  // end of processing that is specific to the first Vsample in each -ve half cycle
       // still processing samples where the voltage is NEGATIVE ...
    // check to see whether the trigger device can now be reliably disarmed
    if ((sampleSetsDuringThisHalfMainsCycle == 3) && (cycleNumberBeingRecorded == 1))
    {
      //setPinOFF(outputForTrigger);  // triac will release at the next ZC point
    }
  }  // end of processing that is specific to samples where the voltage is negative
  //
  // processing for EVERY set of samples
  //
  // extra filtering to offset the HPF effect of CT1
  //
  // subtract the nominal DC offset so the data stream is based around zero, as is required
  // for the LPF, and left-shift for integer maths use.

  if (recordingNow)
  {
    storedSample_I1_from_ADC[samplesRecorded] = sample_I1;
  }

  int32_t sampleI1minusDC_long = ((int32_t)(sample_I1 - DCoffsetI_nominal)) << 10;

  const int32_t last_lpf_long = lpf_long;
  lpf_long = last_lpf_long + alpha * (sampleI1minusDC_long - last_lpf_long);
  sampleI1minusDC_long += (lpf_gain * lpf_long);

  sample_I1 = (sampleI1minusDC_long >> 10) + DCoffsetI_nominal;
  //
  if (recordingNow)
  {
    storedSample_V1[samplesRecorded] = sample_V1;
    storedSample_I1[samplesRecorded] = sample_I1;
    ++samplesRecorded;
  }

  ++sampleSetsDuringThisHalfMainsCycle;
  cumVdeltasThisCycle_long += sample_VminusDC_long;     // for use with LP filter
  polarityOfLastVsample = polarityOfMostRecentVsample;  // for identification of half cycle boundaries
}  // end of allGeneralProcessing()

void dispatch_recorded_raw_data()
{
  // display raw samples via the Serial Monitor
  // ------------------------------------------

  Serial.println("Raw data:");

  for (uint16_t index = 0; index < samplesRecorded; ++index)
  {
    Serial.print("V: ");
    Serial.print(storedSample_V1[index]);
    Serial.print(" - I1_from_ADC: ");
    Serial.print(storedSample_I1_from_ADC[index]);
    Serial.print(" - I1: ");
    Serial.println(storedSample_I1[index]);
  }
}

void dispatch_recorded_data()
{
  // display raw samples via the Serial Monitor
  // ------------------------------------------

  Serial.print("cycleCount ");
  Serial.print(cycleCount);
  Serial.print(", samplesRecorded ");
  Serial.println(samplesRecorded);

  int V, I1, I1_from_ADC;
  int min_V{ 1023 };
  int min_I1{ 1023 };
  int min_I1_from_ADC{ 1023 };
  int max_V{ 0 };
  int max_I1{ 0 };
  int max_I1_from_ADC{ 0 };

  for (uint16_t index = 0; index < samplesRecorded; ++index)
  {
    strcpy(newLine, blankLine);
    V = storedSample_V1[index];
    I1 = storedSample_I1[index];
    I1_from_ADC = storedSample_I1_from_ADC[index];

    if (V == 999)
    {
      Serial.println("Trigger ON");
      continue;
    }
    else if (V == 0)
    {
      Serial.println("Trigger OFF");
      continue;
    }

    if (V < min_V)
    {
      min_V = V;
    }
    if (V > max_V)
    {
      max_V = V;
    }
    if (I1 < min_I1)
    {
      min_I1 = I1;
    }
    if (I1 > max_I1)
    {
      max_I1 = I1;
    }

    if (I1_from_ADC < min_I1_from_ADC)
    {
      min_I1_from_ADC = I1_from_ADC;
    }
    if (I1_from_ADC > max_I1_from_ADC)
    {
      max_I1_from_ADC = I1_from_ADC;
    }

    newLine[map(V, 0, 1023, 0, 80)] = 'V';

    int halfRange = 200;
    int lowerLimit = 512 - halfRange;
    int upperLimit = 512 + halfRange;
    if ((I1 > lowerLimit) && (I1 < upperLimit))
    {
      newLine[map(I1, lowerLimit, upperLimit, 0, 80)] = '1';  // <-- raw sample scale
    }

    if ((index % 1) == 0)  // change this to "% 1" for full resolution
    {
      Serial.println(newLine);
    }
  }

  Serial.print("min_V ");
  Serial.print(min_V);
  Serial.print(",  max_V ");
  Serial.println(max_V);
  Serial.print("min_I1 ");
  Serial.print(min_I1);
  Serial.print(",  max_I1 ");
  Serial.println(max_I1);
  Serial.print("min_I1_from_ADC ");
  Serial.print(min_I1_from_ADC);
  Serial.print(",  max_I1_from_ADC ");
  Serial.println(max_I1_from_ADC);

  Serial.println();

  recordingNow = false;
  firstLoop = true;

  pause();
}

void pause()
{
  bool done = false;
  byte dummyByte;

  while (done != true)
  {
    if (Serial.available() > 0)
    {
      dummyByte = Serial.read();  // to 'consume' the incoming byte
      if (dummyByte == 'g')
      {
        done = true;
      }
    }
  }
}

int freeRam()
{
  extern int __heap_start, *__brkval;
  int v;
  return (int)&v - (__brkval == 0 ? (int)&__heap_start : (int)__brkval);
}