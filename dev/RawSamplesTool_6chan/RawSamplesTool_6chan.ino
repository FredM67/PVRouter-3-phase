/*
 * Tool to capture the raw samples generated by an Arduino during several mains
 * cycles.  This data is displayed on the Serial Monitor, and is also available
 * for subsequent processing using a spreadsheet. 
 *
 * Pauses after each set of measurements has been taken.  Press 'g', then [cr], 
 * to repeat.
 *
 *      Robin Emley (calypso_rae on Open Energy Monitor Forum)
 *      December 2012
 */
 
#define POSITIVE 1
#define NEGATIVE 0
#define ON 0  // the external trigger device is active low
#define OFF 1

/*
byte sensorPin_V1 = 0;
byte sensorPin_V3 = 1;
byte sensorPin_I1 = 2;
byte sensorPin_V2 = 3;
byte sensorPin_I2 = 4;
byte sensorPin_I3 = 5;
*/

byte sensorPin_V1 = 0;
byte sensorPin_I1 = 1;
byte sensorPin_V2 = 2;
byte sensorPin_I2 = 3;
byte sensorPin_V3 = 4;
byte sensorPin_I3 = 5;

long cycleCount = 0;
int samplesRecorded = 0;
float cyclesPerSecond = 50; // use float to ensure accurate maths

byte polarityNow; 
boolean beyondStartUpPhase = false;
byte currentStateOfTriac;

int lastSample_V1;     // stored value from the previous loop (HP filter is for voltage samples only)         
float lastFiltered_V1;  //  voltage values after HP-filtering to remove the DC offset
byte polarityOfLastSample_V1; // for zero-crossing detection
  
boolean recordingNow;
boolean recordingComplete;
byte cycleNumberBeingRecorded;
byte noOfCyclesToBeRecorded;

unsigned long recordingMayStartAt;
boolean firstLoop = true;
int settlingDelay = 5; // <<---  settling time (seconds) for HPF 

char blankLine[82];
char newLine[82];
int storedSample_V1[50]; 
int storedSample_V2[50]; 
int storedSample_V3[50];
int storedSample_I1[50];
int storedSample_I2[50];
int storedSample_I3[50];

void setup()
{  
  delay(3000);
  Serial.begin(9600);
 
  // initialise each character of the display line
  blankLine[0] = '|';
  blankLine[80] = '|';
  
  for (int i = 1; i < 80; i++)
  {
    blankLine[i] = ' ';
  }
  
  blankLine[40] = '.';
  
  Serial.print(">>free RAM = ");
  Serial.println(freeRam());  // a useful value to keep an eye on

}


/*  Allow the system to run for several seconds so that the filtered 
 *  voltage waveform can settle down.  This info is needed for determining 
 *  the start of each new mains cycle.  During this period, a countdown 
 *  is displayed.
 *
 *  After the settling period has expired, raw samples taken during 
 *  one complete mains cycle are stored in an array.  The capacity of the 
 *  array needs to be sufficient for the number of sample pairs that may
 *  appear.  A 100 x 2 integer array will probably suffice.
 *
 *  At the start of the following cycle, the data collected during the 
 *  previous cycle data is sent to the Serial window.  
 */
void loop() // each iteration of loop is for one pair of measurements only
{
  if(firstLoop)
  {
    unsigned long timeNow = millis();
    Serial.print ("millis() now = ");
    Serial.println (timeNow);
    
    recordingMayStartAt = timeNow + (settlingDelay * 1000);
    Serial.print ("recordingMayStartAt ");
    Serial.println (recordingMayStartAt);
    
    recordingNow = false;
    firstLoop = false;
    recordingComplete = false;
    noOfCyclesToBeRecorded = 1;
    cycleNumberBeingRecorded = 0;
    samplesRecorded = 0;    
  }
  
  int sample_V1 = analogRead(sensorPin_V1);                 //Read in raw voltage signal
  int sample_I1 = analogRead(sensorPin_I1);                 //Read in raw current signal
  int sample_V2 = analogRead(sensorPin_V2);                 //Read in raw voltage signal
  int sample_I2 = analogRead(sensorPin_I2);                 //Read in raw current signal
  int sample_V3 = analogRead(sensorPin_V3);                 //Read in raw current signal
  int sample_I3 = analogRead(sensorPin_I3);                 //Read in raw current signal

  float filtered_V1 = 0.996*(lastFiltered_V1 + sample_V1 - lastSample_V1); 

  byte polarityOfThisSample_V1;
  if(filtered_V1 > 0)
  {
    polarityOfThisSample_V1 = POSITIVE;
    
    if (polarityOfLastSample_V1 != POSITIVE) 
    {
      // This is the start of a new mains cycle
      cycleCount++; 
         
      if (recordingNow == true) {
        if (cycleNumberBeingRecorded >= noOfCyclesToBeRecorded) {
          Serial.print ("No of cycles recorded = ");
          Serial.println (cycleNumberBeingRecorded);      
          dispatch_recorded_data(); } 
        else {
          cycleNumberBeingRecorded++; } }    

      else
      if((cycleCount % 50) == 1) {  
        unsigned long timeNow = millis();   
        if (timeNow > recordingMayStartAt) {
           recordingNow = true;
           cycleNumberBeingRecorded++; } 
        else  {
          Serial.println((int)(recordingMayStartAt - timeNow) / 1000); } }    
    } // end of specific processing for first +ve reading in each mains cycle
    
  } // end of specific processing of +ve cycles
  else
  {
    polarityOfThisSample_V1 = NEGATIVE; 
    
    if (polarityOfLastSample_V1 != NEGATIVE) 
    {
      // at the start of a new negative half cycle
    }
  }
  
  if (recordingNow == true)
  {
    storedSample_V1[samplesRecorded] = sample_V1;
    storedSample_V2[samplesRecorded] = sample_V2;
    storedSample_V3[samplesRecorded] = sample_V3;
    storedSample_I1[samplesRecorded] = sample_I1;
    storedSample_I2[samplesRecorded] = sample_I2;
    storedSample_I3[samplesRecorded] = sample_I3;
    samplesRecorded++;
  }
    
  polarityOfLastSample_V1 = polarityOfThisSample_V1;  
  lastSample_V1 = sample_V1;                       
  lastFiltered_V1 = filtered_V1;                  
} // end of loop()


void dispatch_recorded_data()
{      
  // display raw samples via the Serial Monitor
  // ------------------------------------------ 

  Serial.print("cycleCount ");
  Serial.print(cycleCount);
  Serial.print(",  samplesRecorded ");
  Serial.println(samplesRecorded);

  int V1, I1;
  int min_V1 = 1023, min_I1 = 1023;
  int max_V1 = 0, max_I1 = 0;
  int V2, I2;
  int min_V2 = 1023, min_I2 = 1023;
  int max_V2 = 0, max_I2 = 0;
  int V3, I3;
  int min_V3 = 1023, min_I3 = 1023;
  int max_V3 = 0, max_I3 = 0;
      
  for (int index = 0; index < samplesRecorded; index++) 
  {
    strcpy(newLine, blankLine);
    V1 = storedSample_V1[index]; 
    I1 = storedSample_I1[index]; 
    V2 = storedSample_V2[index]; 
    I2 = storedSample_I2[index]; 
    V3 = storedSample_V3[index]; 
    I3 = storedSample_I3[index]; 
 
    if (V1 < min_V1){min_V1 = V1;}
    if (V1 > max_V1){max_V1 = V1;}
    if (I1 < min_I1){min_I1 = I1;}
    if (I1 > max_I1){max_I1 = I1;}
    
    if (V2 < min_V2){min_V2 = V2;}
    if (V2 > max_V2){max_V2 = V2;}
    if (I2 < min_I2){min_I2 = I2;}
    if (I2 > max_I2){max_I2 = I2;}
    
    if (V3 < min_V3){min_V3 = V3;}
    if (V3 > max_V3){max_V3 = V3;}
    if (I3 < min_I3){min_I3 = I3;}
    if (I3 > max_I3){max_I3 = I3;}
    
    newLine[map(V1, 0, 1023, 0, 80)] = '0'; 
    newLine[map(I1, 0, 1023, 0, 80)] = '1'; 
    newLine[map(V2, 0, 1023, 0, 80)] = '2'; 
    newLine[map(I2, 0, 1023, 0, 80)] = '3'; 
    newLine[map(V3, 0, 1023, 0, 80)] = '4'; 
    newLine[map(I3, 0, 1023, 0, 80)] = '5'; 
              
    if ((index % 1) == 0) // change this to "% 1" for full resolution
    {
      Serial.println(newLine);
    }
  }
    
  Serial.print("min_V1 ");  Serial.print(min_V1);
  Serial.print(",  max_V1 ");  Serial.print(max_V1);
  Serial.print(",  min_I1 ");  Serial.print(min_I1);
  Serial.print(",  max_I1 ");  Serial.println(max_I1);
  
  Serial.print("min_V2 ");  Serial.print(min_V2);
  Serial.print(",  max_V2 ");  Serial.print(max_V2);
  Serial.print(",  min_I2 ");  Serial.print(min_I2);
  Serial.print(",  max_I2 ");  Serial.println(max_I2);
  
  Serial.print("min_V3 ");  Serial.print(min_V3);
  Serial.print(",  max_V3 ");  Serial.print(max_V3);
  Serial.print(",  min_I3 ");  Serial.print(min_I3);
  Serial.print(",  max_I3 ");  Serial.println(max_I3);
  
  
  Serial.println();
  Serial.println();
      
  // despatch raw samples via the Serial Monitor 
  // ------------------------------------------- 
      
  Serial.println("Raw data from stored cycle: <Vsample>,<Isample>[cr]");
  Serial.print(samplesRecorded);
  Serial.println(", <<< No of sample pairs");

  for (int index = 0; index < samplesRecorded; index++) 
  {
    Serial.print (storedSample_V1[index]); 
    Serial.print(','); 
    Serial.println (storedSample_I1[index]);  
  }

  recordingNow = false;
  firstLoop = true;
  pause();
}      

void pause()
{
  byte done = false;
  byte dummyByte;
   
  while (done != true)
  {
    if (Serial.available() > 0)
    {
      dummyByte = Serial.read(); // to 'consume' the incoming byte
      if (dummyByte == 'g') done++;
    }
  }    
}

int freeRam () {
  extern int __heap_start, *__brkval; 
  int v; 
  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
}


